# Лабораторная 1: вставки и переходы


### Вступительное слово

В нулевой лабе вы познакомились с основными командами центрального процессора: арифметикой и копированием данных.
Если у вас осталось ощущение, что компьютер -- это просто калькулятор-переросток, вы все делаете правильно.

То, чем вы занимались в нулевой лабе -- это, по сути, реверс-инжиниринг компилятора.
Вы смотрите, что он делает, и пытаетесь понять, как он устроен. 
И то, как устроен сам процессор, которому он отдает команды. 

Также вы могли заметить, что найти информацию в интернете по этим темам непросто.
Поиск будет отправлять вас на то на устаревшие страницы про 16-битную архитектуру, то на очень подробную документацию, то на форумы, где среди жаргона будут понятны только предлоги.
Архитектура ЭВМ -- это тема, в которую довольно сложно вгрузиться с нуля.
Чтобы дойти от самых основ до устройства современных процессоров, нужно много времени (порядка пары годовых курсов) и/или энтузиазма.
Проще говоря, нужно учиться на другой специальности.
В рамках этого курса вы сможете освоить базовую терминологию, чтобы понимать объяснения людей этой cамой специальности, почему ваш код не работает.
Помимо этого, вы освоите основные инструменты и подходы, с помощью которых и сами сможете исследовать какие-то неочевидные особенности компилятора С++.
Вначале -- на простых примерах. Потом на более сложных.

Итак, поехали дальше.
Вам нужно понять, как управлять центральным процессором своими руками, а не просто смотреть на выдачу компилятора. 
Проще всего это сделать с помощью ассемблерных вставок. 
Вначале вам нужно будет посмотреть, как выглядят команды для цикла и условия в ассемблерном листинге, а потом решить несколько простых алгоритмических задач.
Тогда и материал первой лабы лучше уложится -- вы поймете, где вы правда поняли, а где на самом деле не очень.

Небольшая рекомендация.
На уровне ассемблера программирование механистичное, детерминированное и довольно простое (пока не надо писать что-то большое).
Вам нужно следить не столько за переменными, сколько за данными -- регистрами, кусочками памяти и тем, сколько байтов и куда вы кладете.
Если вы привыкнете смотреть на свой код таким образом, то и с отладкой плюсового кода проблем будет немного меньше. 

### Отчётность и формальные моменты

В отчете можете не идти по пунктам, просто опишите следующее:
- как выглядят метки, команды перехода, условия и циклы в листинге;
- как выглядят одномерные и двухмерные глобальные массивы;
- как вы реализовали сортировку 
- (*) и как быстро она работает в сравнении с оптимизациями О0-О3 (с графиками). (Это пункт со звездочкой.)

Помимо отчета, вам нужно прислать свою сортировку - тот файл sort.h, который получился в последнем пункте. 
Будет сводная табличка и общий график по группе, можно присылать обновления и гоняться с коллегами.

## Задания

1. Написать программу на С с использованием ассемблерной вставки (GCC Inline Assembly) из нескольких строк. Сгенерировать листинг программы и осознать, как вставка выглядит в листинге. 
2. Получить в листинге метки и дополнить ими ассемблерную вставку.
3. Получить в листинге по крайней мере одну из команд перехода.
4. Получить в листинге оператор сравнения.
5. Определить, как в ассемблере производится работа с глобальными массивами -- одномерными и двухмерными:\
    a. инициализация;\
    b. обращение к элементу.

Последующие задания можно выполнять как модификацией листинга, так и при помощи вставки.

6. Проверить, как работают различные команды перехода:
    a. условные;
    b. безусловная.
7. Организовать:\
    a. условный оператор (`if`);\
    b. операторы цикла `for`, `while`, `until`;\
    при помощи различных команд перехода.
8. Проверить работу оператора `loop`.

Последующие задания нужно выполнить при помощи ассемблерной вставки. Код на С разрешается использовать только для ввода и вывода массива. Так интереснее.

9. Найти максимум из двух чисел (`if`).
10. Найти сумму элементов массива (`for`).
11. Найти максимальный элемент в массиве (`if`, вложенный в `for`).
12. Вывод текущего элемента на каждой итерации при поиске максимального элемента в массиве (разрыв ассемблерной вставки).
13. Сортировка массива за O(N<sup>2</sup>) (вложенные циклы).
14. А теперь нужно вписаться в профайлер, который лежит в папке bubble\_profiler. 
Для этого нужно заменить сортировку в функции sort(), которая лежит в sort.h, вашей ассемблерной вставкой. После этого скомпилировать sort\_profiler.cpp. 
Обратите внимание, что в вашей вставке нужно использовать глобальные переменные профайлера - массив а и размер массива n. 
