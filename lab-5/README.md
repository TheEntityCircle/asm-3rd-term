# Лабораторная 5: Числа с плавающей точкой (Asm)


### Вступительное слово

Продолжаем разборки с флоатами.

В этой лабораторной мы смотрим на них средствами ассемблера - как они обрабатываются и как ускорить их вычисления.

### Отчётность и формальные моменты

Отчет по лабе снова состоит из двух разделов, они как бы продолжают разделы предыдущей лабы. 

Нулевой раздел обязательный, в нем нужно посмотреть своими руками базу по архитектуре сопроцессора. 

Первый раздел продолжается - Путь Геометра или Путь Художника. 

## Задания

### Нулевой раздел. Расчеты на сопроцессоре.

Кусочек теории по [математическому сопроцессору](https://youtu.be/rgHVuu1AQNw?list=PLecy9mZ2ycLKgUPtGIFAcz5NN_zzFQT_-&t=603).
	
#### 0. База.

Посмотрите, как в ассемблерном листинге выглядят float и double -- инициализация, арифметические операции.
Обратите внимание, что команды заметно другие.

#### 1. Поиск среднего.

Напишите на С/С++ код, который ищет среднее арифметическое массива из 16 вещественных чисел. 

Сгенерируйте и проанализируйте ассемблерный листинг при различных автоматических оптимизациях. 

Дальше вам нужно ускорить код двумя разными способами, вначале одним, потом другим. 
*Применить их одновременно -- задача нетривиальная, но тоже можете отдельно попробовать.*

Первый способ -- ускорьте задачу за счет распараллеливания сложения при помощи SSE (ассемблерная вставка). 

Второй способ -- ускорьте задачу за счет конвейера операций.
Как вы уже поняли, расчет на основном процессоре и на сопроцессоре происходит независимо.
У них разные регистры и разные команды.
Более того -- расчет на них происходит еще и одновременно.
Если вы сбалансируете количество целочисленных и нецелочисленных вычислений в рамках одной итерации цикла, код будет работать существенно быстрее, чем при обычной реализации.
В рамках данной задачи это делается следующим образом: вам нужно накапливать сумму не в одной переменной, а в двух.
В первой -- сумма элементов с четными номерами, во второй -- с нечетными. 
После окончания цикла просто сложить эти частичные суммы и выдать результат.
Такой неочевидный ход позволяет увеличить количество нецелочисленных операций на одну итерацию цикла (а то целочисленных там обычно много -- это и увеличение счетчика, и проверка, и переходы).
Попробуйте вместо двух частичных сумм сделать три, четыре и так далее.
*Можете еще определить, какое количество является оптимальным.*

Засеките время работы на размерах массива 16..160000. 
Постройте графики и сравните с автоматический оптимизацией.
*Да, этот как раз тот случай, когда мы портим читаемость кода ради скорости его работы.*

### Путь Геометра

После предыдущей лабы у вас остался код, который считает площадь под графиком различными методами. 
Там он был нужен для измерения точности этих методов.
Теперь нас интересует, как быстро они работают.

Постройте графики зависимости времени расчета площади от количества прямоугольников. 
*Если расчет слишком быстрый, и точности таймера не хватает, нужно проводить большое количество расчетов на одно измерение времени, а потом усреднять по количеству повторов.*

Постройте аналогичные графики для разных автоматических оптимизаций.

Дальше вам нужно выполнить хотя бы один из следующих пунктов (*лучше все, но тогда это уже задание со звездочкой, к которому можно вернуться вообще после окончания семестра*).

0. Улучшите автоматическую оптимизацию вручную. 
Просмотрите ассемблерный листинг после О2. 
Вручную перепишите те его кусочки, которые вам кажутся медленными.
Постройте графики, которые покажут, получилось у вас или нет.
*Возможно, будет проще работать, если вы вынесете расчетные кусочки кода в отдельные функции и даже отдельные файлы, а потом будете модифицировать только листинг этих отдельных кусочков. Тогда не нужно будет таскать за собой в листинге тяжелую периферию, связанную с вводом, выводом и измерением времени. Модифицированные расчетные кусочки компилируйте в отдельные объектные файлы и соединяйте с периферией на этапе линковки. Вспомните схему сборки с предыдущего семестра, тут она сильно упростит вам работу.*

1. Выбейте из автоматической оптимизации максимум.
В нулевом пункте вы уже организовывали конвейер, попробуйте сделать тут аналогично.
Если вам повезло, то в предыдущем пункте вы увидели еще и автоматическую векторизацию -- иногда компилятор сам использует SSE на полную. 
Попробуйте модифицировать код на С/С++ так, чтобы он начал работать быстрее.
*Скорее всего, придется пожертвовать его красотой.*
Заглядывайте в листинги и стройте графики, чтобы убедиться, на правильном ли вы пути.

2. Напишите на ассемблере с нуля.
*Зачем играть в армрестлинг с компилятором, если можно все сделать самостоятельно?* 
Периферию (ввод/вывод, измерение времени) лучше все-таки у компилятора взять.
А вот расчетные кусочки вынести отдельно и, не опираясь на готовые листинги, написать ту же расчетную логику с нуля на ассемблере. 
Потом постройте графики, которые покажут, получилось у вас или нет.

### Путь Художника

Итак, у вас есть код для расчета двух тел и визуализация к нему. 

Часть итоговой программы, если у вас OpenGL/Vulkan/DirectX (SFML тоже, потому что это обертка над OpenGL), будет выполняться на видеокарте.
На самом деле, это графический сопроцессор, и он устроен во многом похоже на SSE, просто побольше на несколько порядков. 
Разбираться с ним, чтобы грамотно ускорять работу кода с его помощью -- задача долгая и нетривиальная.
Расчеты на видеокартах больше похожи на наладку конвейера на заводе.
Нужно изучить архитектуру видеокарты, с которой работаете, как устроена оперативная память, какие есть кэши и времена отклика. 
А потом организовать погрузку и отгрузку байтов, порезанных кусочками нужного размера, чтобы у разных частей конвейера не было застоев. 
Это -- предмет отдельного курса. 

Поэтому давайте попробуем ускорить ваш код с помощью SSE.
У него архитектура аналогичная, но поменьше, и так глубоко в железо залезать не надо.

Прежде всего, вам понадобится метрика для времени.
*Прикидывать "на глаз", стало ли быстрее, не прокатит.*
Обычно используют FPS (frames per second). 
Разберитесь, как в вашем коде связаны шаг расчета и шаг отрисовки. 
Придумайте, как лучше измерять FPS (чтобы сами эти проверки не портили время работы, особенно при выводе на экран).

Проведите разные расчеты, оцените, в каких пределах колеблется ваша метрика измерения времени.

Ускорьте отдельные кусочки вашего кода одним из способов, которые расписаны в Пути Геометра -- модификацией оптимизированного листинга, модификацией кода на С/С++ или написанием ассемблерного кода с нуля.
Проверьте, стало ли лучше.
