# Лабораторная 2: стек и локальные переменные


### Вступительное слово

В рамках следующих двух лабораторных работ, помимо прочего, мы хотим посмотреть на различие архитектур Intel х32 и х64. На разные архитектуры стоит посмотреть, чтобы понять, чем они вообще могут отличаться, а эти две точно есть у всех под рукой. 
Скорее всего, установленный по умолчанию компилятор с ходу в х32 не сможет. Вот что надо сделать, чтобы смог (если у вас не Убунта, а другой дистрибутив, то ищите аналогичную библиотеку):

`sudo apt-get install g++-multilib libc6-dev-i386`\
`gcc 1.c -o 1.s -S -m32`

### Отчётность и формальные моменты

Лаба довольно большая. На скрупулёзное оформление всех её пунктов ушло бы очень много времени. Мы решили упростить вам задачу. В отчёт вставляйте лишь то, что расширило лично ваше понимание работы кода (считайте, что пишете сочинение на тему "Что нового я узнал про С++"). С примерами кода и листингами, естественно, но главное -- тезисы, сформулированные лично вами и отражающие ваши знания о работе локальных переменных.

## Задания

1. Сгенерировать листинг, в котором вызывается функция:\
    a. без аргументов и возвращаемых значений;\
    b. без аргументов и с возвращаемым значением (int/char);\
    c. с одним аргументом;\
    d. с несколькими аргументами.\
    Сгенерировать листинг для 64-х и 32-х битной (флаг -m32) архитектур.

По существу, генерации разнообразных листингов посвящены все остальные задания. По мере сил смотрите обе архитектуры -- х32 для понимания основ, х64 -- как оно работает у вас на машине. Особо пытливые могут смотреть ещё и на разницу С и С++.

2. Посмотрим на локальные переменные:\
    a. одна локальная переменная;\
    b. 2-3 локальных переменных;\
    c. статический массив;\
    d. динамический массив.
3. У нас же еще структуры есть:\
    a. напишите структуру на 3-4 поля разного типа без методов;\
    b. создайте одну глобальную переменную этого типа и повызывайте ее поля из main’a;\
    c. добавьте статический массив как поле;\
    d. добавьте структуру в аргументы функции;\
    e. добавьте структуру в возвращаемые значения функции;\
    f.* вообще-то можно и про методы посмотреть, как они выглядят...\
    g.* а еще есть операторы...
4. А теперь посложнее. Разберемся с референсами. Пусть теперь функция будет:\
    a. со структурой в аргументе;\
    b. с указателем на структуру в аргументе;\
    c. со ссылкой на структуру в аргументе;\
    d.* а помните, была такая штука, как rvalue-ссылки? Как они устроены? 
5. Посмотрели на штатную работу, теперь давайте проверять все это дело на прочность. На примере жирных структур – чтобы не просто 3-4 небольших поля, а здоровенный статический массив. Пусть теперь функция будет:\
    a. с жирной структурой в аргументе;\
    b. с жирной структурой в возвращаемом значении;\
    c. с жирной структурой в локальной переменной;\
    d. поменять размер структуры, изменится ли что-то? А на х32? 
6. Написать код на С или C++, использующий рекурсивную функцию. Сгенерировать и проанализировать листинг для различных архитектур. Оценить размер стека, который отводится под программу (экспериментально, по характерному треску).  