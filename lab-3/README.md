# Лабораторная 3: Библиотеки, бинарники и оптимизация


### Вступительное слово

В этой лабораторной работе мы попробуем соединить те знания, которые у вас уже есть.

Первое - понимание того, что такое статические и динамические библиотеки.
Чем они отличаются, как устроены (в общих чертах) и зачем вообще нужны.
Если вы не очень запомнили с [прошлого семестра](https://github.com/TheEntityCircle/lfb-2nd-term), то как раз запомните сейчас.

Второе - тезис "для программиста на ассемблере любая программа - это проект с открытым кодом".
Давайте попробуем читать ассемблерный листинг не как промежуточный этап сборки, а непосредственно те бинарники, которые потом исполняются.

Заодно, желающие могут посмотреть на то, как работает оптимизация. 
Эта тема не очень связана с библиотеками - честно говоря, она просто не влезала в другие лабы.


### Отчётность и формальные моменты

Отчет по лабе состоит из двух разделов (нумерация с нуля, раз уж так начали). 

Нулевой раздел обязательный, в нем нужно отразить разницу между статическими и динамическими библиотеками. 
Наглядно, с примерами ассемблерного листинга.

Первый раздел на выбор - Путь Хакера или Путь Самурая. 
На Пути Хакера отчет можно не писать - главное, восстановить пароли и немного словами пояснить, что вы делали.
На Пути Самурая отчет писать надо.
Как и в прошлой лабе, можно без лишних деталей - главное, написать, что вы поняли про оптимизацию в С/С++.

## Задания

### Нулевой раздел. Библиотеки и чтение бинарников.

Для начала, освежите в памяти материал (прошлого семестра)[https://github.com/TheEntityCircle/lfb-2nd-term/tree/main/lab\_5]
*Те лабы в целом полезно держать под рукой. В них много полезных инструкций и ссылок, по которым можно что-то быстро вспомнить.*

Теперь сделайте статическую библиотеку, в которой есть одна простая функция на ассемблере (см. файл sum\_x64.s) и подключите его к проверяющему коду (в base.c).
Если у вас неинтеловская архитектура или какие-то особенности компилятора, то напишите sum.s сами с учетом того, что вы узнали за первые три лабы.
Проверьте ее работоспособность. 

Теперь попробуйте прочитать получившийся исполняемый файл. 
Для этого есть два очень стандартных инструмента: objdump и vim. 
Те, кто этим занимается профессионально, использует инструменты посложнее и более специализированные.
Для того, чтобы получить основное представление, хватит и этих.

Чтобы читать сам код, инструкции компилятору, удобнее всего использовать objdump: ```objdump -D base```.
Флаг ```-D``` говорит о том, что вы хотите прочитать все секции бинарника.
```base``` - название бинарника (в нашем случае исполняемый файл, но объектные файлы так тоже можно читать, и библиотеки).
А вот так можно посмотреть дизассемблер конкретной секции: ```objdump -d base --section=.text```.

Поищите там содержимое функции sum.

Теперь проделайте все то же с динамической библиотекой.
Поищите в итоговом исполняемом файле функцию sum.

Попробуйте также почитать и модифицировать бинарники через vim.
Для этого вам понадобится две команды: ```:%!xxd```, которая включает режим HEX-редактирования, и ```:%!xxd -r```, которая его выключает.
*А еще есть совет экспериментировать на простом бинарнике типа Hello World.*

Если вы просто откроете вимом бинарник, то увидите мешанину из символов, разрозненных строк с данными и ключевое слово ELF (executable/linkable file) наверху. 
Чтобы увидеть что-то более осмысленное, вам нужно перейти в режим HEX-редактирования. 
Инструкций вы там не увидите, но байты бинарника будут упорядочены так же, как это делает objdump.
Можно найти нужный и его изменить. 

Для теста этой механики: 
- измените текстовую константу (тот Hello World, который вы выводите в программе), 
- **выйдите из режима HEX-редактирования**, 
- сохраните бинарник,
- запустите его.

Как вы могли уже понять, так можно менять не только текстовые данные, но и инструкции. 
В том числе команды перехода и метки.

### Путь Хакера

Как вы, опять же, могли уже понять, все эти инструменты и механики применяются при взломе программ, создании кейгенов, написании вредоносного кода, а также защиты от всего вышеописанного.
Если вы не понимаете, как это работает, то и защищенного кода написать не сможете.
Способы нападения и защиты развиваются, опираясь друг на друга.
Одни люди придумывают новые методы нападения, другие - новые методы защиты, третьи придумывают, как эти новые методы обойти, и так далее.
Это очень большая и непростая область.
Сейчас вы можете попробовать свои силы и понять, интересна ли вам вообще эта тематика.

В папке ```way_of_hacker``` лежат несколько бинарников (g++, Intel x64), каждый из которых спрашивает пароль. 
Они расположены примерно по возрастанию сложности.
Попробуйте расколоть хотя бы половину.

А если хотите больше и сложнее, то вам сюда:
https://crackmes.one/crackme/646627a933c5d439389131d9

### Путь Самурая

Кто-то уже на прошлых лабах мог заметить, что флаги компилятора -О1, -О2 и -О3 сильно влияют на листинг. 
Компилятор вырезает лишние куски кода и переменные, сам считает что-то, что может посчитать из констант, и вообще как будто читерит - вместо того, чтобы делать то, что вы ему сказали, он как бы имитирует ту же деятельность минимальными усилиями.
А чуть-чуть код поменяли, и он уже другие куски вырезал.

Попробуйте найти в этой магии закономерности.

Как вы можете помнить, флаги оптимизации -О являются как бы "подборками" более мелких флагов, каждый из которых включает какой-то отдельный алгоритм оптимизации. 
Выберите из (списка)[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html] несколько (4-6) этих мелких флагов -f и исследуйте, как они влияют на листинг. 
Можно смотреть и сам листинг, и бинарник через objdump.
Постарайтесь сами определить, как лучше.
